<?php

// Регулярные выражения окружаются с двух сторон с тильдой или /

preg_match(

    // что ищем

    '~cats~',

    // где ищем

    'It rains cats and dogs.',
    // некая переменная, куда будут сложены результаты поиска
    $m
);

// Результаты всегда получаем в виде массива

//var_dump($m);


/*
Любой символ обозначается точкой "."
Чтобы записать саму точку, нужно написать: "\."
Это называется экранирование
*/

// Результат: cat
preg_match('~c.t~', 'It rains cats and dogs.', $m);
//var_dump($m);

// Результат: dogs.
// Как заметили, мы записали \. для того, чтобы ставить
// как обычную точку, а не исполнять .
// Хотите заэкранировать слэш \ , тогда пишите 2 раза слэш
preg_match('~dogs\.~', 'It rains cats and dogs.', $m);
//var_dump($m);

//В этом случае охватывает первое вхождение, т.е.: ains (из rains)
// rains - первый, cats - второй, dogs - третий
// Пробел тоже считается как символ, это тоже нужно учесть
preg_match('~...s~', 'It rains cats and dogs.', $m);

//preg_match_all охватывает все 3 вхождения (rains, cats, dogs)
preg_match_all('~...s~', 'It rains cats and dogs.', $m);


// Квантификатор или указатель количества
// Специальные символы, которые задают повторения

// ca{1,2}t - первое число - минимальное повторение
// нужного нам символа, а второе максимальное, включительно

preg_match_all(
    // мы ищем cats и caats
    '~ca{1,2}t~',
    'It rains cats, caats, caaats and dogs.',
    $m
);

preg_match_all(
// мы ищем caats и caaats
    '~ca{2,3}t~',
    'It rains cats, caats, caaats and dogs.',
    $m
);


preg_match_all(
// ? означает что "a" есть 1 раз, либо нет вообще
    '~ca?t~',

// результат: cts, cats

    'It rains cts, cats, caats, caaats and dogs.',
    $m
);


preg_match_all(
// + означает что "a" есть 1 или более раз
    '~ca+t~',

// результат: cats, caats, caaats

    'It rains cts, cats, caats, caaats and dogs.',
    $m
);


preg_match_all(
// * означает что "a" есть 0 или более раз
    '~ca*t~',

// результат: cts, cats, caats, caaats
// т.е. найдет все

    'It rains cts, cats, caats, caaats and dogs.',
    $m
);



// Поиск регулярных выражений: Жадные и нежадные

// По умолчанию поиск в регулярных выражениях жадный
// Захватывает максимальную возможную

// Сейчас поищем (жадный поиск)

preg_match_all(
    // находим ненулевое слово. Будет искать до последнего возможного s
    // т.е. результат: cats and dogs
    '~c.+s~',
 'It rains cats and dogs',
    $m

);

// Нежадный поиск

preg_match_all(
// Добавим ? и он станет нежадным
// т.е. результат: cats
    '~c.+?s~',
    'It rains cats and dogs',
    $m

);


// Есть так называемые режимы работы регулярок

preg_match_all(
// Добавим U (от слова: ungreedy, нежадный) и он переключит режим работы
// результат: cats
    '~c.+s~U',
    'It rains cats and dogs',
    $m

);


preg_match_all(
// Находим по двум запросам (c.+?s~ и ~c.+s).
// Результат: cats и cats and dogs
    '~c.+?s~, ~c.+s~',
    'It rains cats, cats and dogs.',
    $m

);


preg_match_all(
// Если добавить U, то он полностью станет нежадным
// Результат: cats и cats
    '~c.+?s~, ~c.+s~',
    'It rains cats, cats and dogs.',
    $m

);



//**********Классы символов*************

// Свой класс символов можно задать перечислением в квадратных скобках

/*
[a,b,c] - символ a или b или с
[0-9] - любая цифра от 0 до 9
[a-zA-Z0-9-] - все латинские буквы, цифры и знак "-"
[^0-9] - не цифры
*/

// Пример

preg_match_all(
// Квадратные скобками задаются некий класс символов
// [c,d] и [a,o] - соответствует одному символу данного класса
    '~[c,d][a,o]~',
    'It rains cats, cats and dogs.',
    $m

);




// Поищем котов, у которых есть цифры

preg_match_all(
// Запишем символы от 0 до 9, которые содержат трехзначное число
    '~cats[0-9][3]~',
    'It rains cats11, cats011, cats021, cats031 and dogs.',
    $m

);


// В регулярных выражениях есть заранее заданные классы символов
// Они начинаются с обратного слэша


preg_match_all(
// Находим любое слово с пробелом и табуляцией, в количестве от единицы до бесконечности
    '~cats\s+and~',
    'It rains     cats and dogs.',
    $m

);


preg_match_all(
// C пробелом и табуляцией, более обширный вариант,
// для того чтобы сработала перенос строки. Он кстати тоже пробельный символ
    '~cats[\s\S]*and~',
    "It rains     cats\n and dogs.",
    $m

);



preg_match_all(
// Для десятичных цифр
    '~cats[\d]+~',
    "It rains111 cats1 and cats11 dogs1111.",
    $m

);

preg_match_all(
// Для десятичных цифр
    '~\d+~', '123456', $m

);

preg_match_all(
// А если запишем арабские цифры, то он не читает, так как здесь дело в кодировках
// Поэтому добавляем модификатор u, который говорит, что мы используем юникод
    '~\d+~u', '', $m

);


preg_match_all(
// Любой символ (буквы, цифры, нижняя черточка и т.д.)
'~[\w]+~',
    "6 5 cats1 3 7 dogs111_",
    $m

);



//********************** Якоря в регулярных выражениях ***********************


// Якоря просто дают позицию в символах


// ^ - начало строки
// $ - конец строки


preg_match_all(
    // мы хотим найти it в регулярных выражениях
// Модификатор i делает регулярные выражения недействительным к регистру символов
    '~it~i',
    'It rains cats, it cats and dogs.',
    $m

);

// а если хотим найти в самом начале, то добавим ^
// читается так: начала строки, после которого идут символы it

preg_match_all(
    '~^it~i',
    'It rains cats, it cats and dogs.',
    $m

);


// А сейчас хотим проверить, не стоит ли в конце точка
// Для этого используем $ и не забываем точку экранировать

preg_match_all(
    '~$\.~i',
    'It rains cats, it cats and dogs.',
    $m

);

// Пробуем найти две строчки
// Но он не найдет, т.к. смотрит предложение целиком

preg_match_all(
    '~$\.~i',
    "It rains cats. \nIt cats and dogs.",
    $m

);


// Именно поэтому есть модификатор m (multiple lines, многострочный режим), найдет две точки

preg_match_all(
    '~$\.~m',
    "It rains cats. \nIt cats and dogs.",
    $m

);


//******************* Альтернатива в регулярных выражениях *************************


// Альтернатива - это выбор
// Записывается в виде вариантов
// Может включать пустой вариант



preg_match_all(
    // к примеру ищем животных во множественном числе
    '~(cat|dog)s~m',
    "It rains cats and dogs.",
    $m

);


//А если хотим найти и одиночный s, то пишем пустую альтернативу

preg_match_all(
    '~(cat|dog|)s~m',
    "It rains cats and dogs s.",
    $m

);


//А можно и после кота найти любое количество символов после которого идет a
// Включим нежадный режим

preg_match_all(
    '~(cat|.+)s~U',
    "It rains cats and dogs s.",
    $m

);


//*********************** Рассмотрим тему маски ***************************

// Маски - это часть шаблона, которую не только нужно захватить, но и проверить
// Они в регулярных выражениях записываются в виде круглых скобок
// Все что окружено круглой скобкой является маской


// здесь будет захвачен rains
preg_match_all(
    '~It (\w+)~',
    "It rains cats and dogs s.",
    $m

);


// а здесь: It rains cats (в нулевом элементе массива)
// Подмаски: в первом, втором и т.д.: rains (в первом), cats (во втором) НЕ ЗАБЫВАЕМ ПРОБЕЛ (\w+) (\w+)
preg_match_all(
    '~It (\w+) (\w+)~',
    "It rains cats and dogs.",
    $m

);


// Если добавить ?: то вторая подмаска захвачена не будет, выведет только rains
preg_match_all(
    '~It (\w+) (?:\w+)~',
    "It rains cats and dogs.",
    $m

);


// Подмаскам можно задавать имя, иногда это очень полезно
// Задается таким образом: (?P<имя>)

// Будут выводится таким образом: ключ=>значение, т.е. так: verb=>rains и т.д.

preg_match_all(
    '~It (?P<verb>\w+) (?P<noun>\w+)~',
    "It rains cats and dogs.",
    $m
);

// Еще пример

$str = 'chemwin studwin: 2008';

preg_match_all(
    '~(?P<name>\w+) (?P<name2>\w+): (?P<digit>\d+)~',
    $str,
    $m
);

var_dump($m);

// Пример чуть сложнее:

$str = 'cats cats2 cats3 cats4 - cats5';

preg_match_all(
    '~(?P<nameq2>\w+) (?P<nameq>\w+) (?P<digitt>\w+) (?P<nameq11>\w+) - (?P<namep>\w+)~',
    $str,
    $m
);

var_dump($m);


// Ещё разок пример



$str = 'Harry Potter externally — every inch';

preg_match_all(
    '~(?P<nameq2>\w+) (?P<nameq>\w+) (?P<digitt>\w+) — (?P<nameq11>\w+) (?P<namep>\w+)~',
    $str,
    $m
);

var_dump($m);




// Интересный пример. Оказывается не только для арабских символов,
// но и для русских нужно указать модификатор u


$str = 'Гарри Поттер внешне — вылитый отец';

preg_match_all(
    '~(?P<nameq2>\w+) (?P<nameq>\w+) (?P<digitt>\w+) — (?P<nameq11>\w+) (?P<namep>\w+)~u',
    $str,
    $m
);

var_dump($m);






// А можно и такой вариант:

$str = 'chemwin studwin: 2008';

preg_match_all(
    '~(?P<name>\w+) (?P<name2>\w+). (?P<digit>\d+)~',
    $str,
    $m
);

var_dump($m);


// На уже захваченных подмасках можно ссылаться дальше в тексте

// Пример:

preg_match_all(
    "Сшит колпак не по-колпаковски",
    '~Сшит (\w+) не по-\1овски~',
// Использовали по имени, а второе (?P=what) использовали имя маски
  //  '~Сшит (?P<what>\w+) не по-(?P=what)овски~',
    $m
);

// \1 - ссылка на уже захваченную ранее первую подмаску


/*
 Что изучить:
Валидация различных данных(URL, e-mail, пароль)
Поиск в базах данных
Модуль mod_rewrite сервера Apache
Многие текстовые редакторы ()
 */

//К примеру пароль от 6 символов:
// '~[a-zA-Z][0-9]{6, }~';





